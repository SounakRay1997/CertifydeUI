{"ast":null,"code":"'use strict';\n\nconst isObject = value => typeof value === 'object' && value !== null;\n\nconst mapObjectSkip = Symbol('skip'); // Customized for this use-case\n\nconst isObjectCustom = value => isObject(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);\n\nconst mapObject = function (object, mapper, options) {\n  let isSeen = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new WeakMap();\n  options = {\n    deep: false,\n    target: {},\n    ...options\n  };\n\n  if (isSeen.has(object)) {\n    return isSeen.get(object);\n  }\n\n  isSeen.set(object, options.target);\n  const {\n    target\n  } = options;\n  delete options.target;\n\n  const mapArray = array => array.map(element => isObjectCustom(element) ? mapObject(element, mapper, options, isSeen) : element);\n\n  if (Array.isArray(object)) {\n    return mapArray(object);\n  }\n\n  for (const [key, value] of Object.entries(object)) {\n    const mapResult = mapper(key, value, object);\n\n    if (mapResult === mapObjectSkip) {\n      continue;\n    }\n\n    let [newKey, newValue, {\n      shouldRecurse = true\n    } = {}] = mapResult; // Drop `__proto__` keys.\n\n    if (newKey === '__proto__') {\n      continue;\n    }\n\n    if (options.deep && shouldRecurse && isObjectCustom(newValue)) {\n      newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject(newValue, mapper, options, isSeen);\n    }\n\n    target[newKey] = newValue;\n  }\n\n  return target;\n};\n\nmodule.exports = (object, mapper, options) => {\n  if (!isObject(object)) {\n    throw new TypeError(`Expected an object, got \\`${object}\\` (${typeof object})`);\n  }\n\n  return mapObject(object, mapper, options);\n};\n\nmodule.exports.mapObjectSkip = mapObjectSkip;","map":null,"metadata":{},"sourceType":"script"}